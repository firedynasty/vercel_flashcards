<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Language Flashcards Loader</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Microsoft YaHei", "PingFang SC", system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #fff;
        }

        h1 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #a8d8ea;
            text-align: center;
        }

        /* Sidebar Styles */
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: 250px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #333;
            z-index: 1001;
            background: #1a1a2e;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
        }

        .sidebar.open {
            transform: translateX(0);
        }

        .sidebar-header {
            padding: 15px 10px;
            font-size: 14px;
            font-weight: bold;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #0d0d1a;
            color: #4da6ff;
        }

        .sidebar-header button {
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: inherit;
            font-size: 16px;
        }

        .sidebar-access-code {
            padding: 10px;
            border-bottom: 1px solid #333;
        }

        .sidebar-access-code input {
            width: 80px;
            padding: 8px 12px;
            font-size: 14px;
            border: 2px solid #ff9800;
            border-radius: 6px;
            background: #2a2a2a;
            color: #fff;
            outline: none;
        }

        .sidebar-access-code span {
            margin-left: 8px;
            font-size: 12px;
            color: #888;
        }

        .sidebar-new-file-btn {
            margin: 10px;
            padding: 12px 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
        }

        .sidebar-new-file-btn:hover {
            background: #45a049;
        }

        .sidebar-file-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .sidebar-file-item {
            margin-bottom: 8px;
            padding: 10px;
            background: #2c2c3e;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
        }

        .sidebar-file-item.selected {
            background: #3B82F6;
        }

        .sidebar-file-item:hover {
            background: #3d3d52;
        }

        .sidebar-file-item.selected:hover {
            background: #2563EB;
        }

        .sidebar-file-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 13px;
        }

        .sidebar-file-actions {
            display: flex;
            gap: 4px;
        }

        .sidebar-file-actions button {
            padding: 4px 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .sidebar-edit-btn {
            background: #2196F3;
            color: white;
        }

        .sidebar-delete-btn {
            background: #f44336;
            color: white;
        }

        .sidebar-refresh-btn {
            margin: 10px;
            padding: 10px 16px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
        }

        .sidebar-refresh-btn:hover {
            background: #1976D2;
        }

        .sidebar-no-files {
            padding: 20px;
            color: #888;
        }

        .sidebar-rename-input {
            flex: 1;
            padding: 4px;
            background: #1a1a2e;
            border: 1px solid #444;
            border-radius: 3px;
            color: white;
            font-size: 12px;
        }

        .sidebar-rename-confirm {
            padding: 4px 8px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }

        .sidebar-rename-cancel {
            padding: 4px 8px;
            background: #666;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }

        .sidebar-toggle-btn {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            padding: 8px 16px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .sidebar-toggle-btn:hover {
            background: #1976D2;
        }

        .sidebar.open ~ .sidebar-toggle-btn {
            left: 260px;
        }

        /* Pagination Container */
        #paginationContainer {
            display: flex;
            align-items: center;
            gap: 8px;
            position: fixed;
            top: 10px;
            left: 130px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.15);
            padding: 8px 12px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .sidebar.open ~ #paginationContainer {
            left: 380px;
        }

        .nav-btn {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .nav-btn:hover {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(1.1);
        }

        .nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: none;
        }

        .rating-btn {
            font-size: 14px;
            font-weight: bold;
        }

        .rating-btn.active {
            background: #10B981;
            transform: scale(1.15);
        }

        .counter {
            font-size: 14px;
            color: #fff;
            white-space: nowrap;
            padding: 0 10px;
        }

        /* Main Content Area */
        .main-content {
            margin-top: 70px;
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        /* Flashcard */
        .flashcard-container {
            width: 100%;
            perspective: 1000px;
        }

        .flashcard {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 40px 30px;
            text-align: center;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .flashcard:hover {
            border-color: rgba(168, 216, 234, 0.5);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .chinese-text {
            font-size: 2.5rem;
            line-height: 1.6;
            color: #fff;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .english-text {
            font-size: 1.2rem;
            color: #a8d8ea;
            line-height: 1.5;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .english-text.revealed {
            opacity: 1;
            max-height: 200px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .tap-hint {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 15px;
        }

        .tap-hint.hidden {
            display: none;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 15px;
        }

        button {
            padding: 10px 20px;
            font-size: 1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:active {
            transform: scale(0.95);
        }

        .speak-btn {
            background: #10B981;
            color: white;
        }

        .speak-btn:hover {
            background: #059669;
        }

        .reveal-btn {
            background: #3B82F6;
            color: white;
        }

        .reveal-btn:hover {
            background: #2563EB;
        }

        .clear-btn {
            background: #e74c3c;
            color: white;
        }

        .grid-btn {
            background: #3498db;
            color: white;
        }

        .dark-btn {
            background: #374151;
            color: white;
        }

        .dark-btn.active {
            background: #fbbf24;
            color: #000;
        }

        .expand-btn {
            background: #8b5cf6;
            color: white;
        }

        .expand-btn.active {
            background: #a78bfa;
        }

        .paste-btn {
            background: #8b5cf6;
            color: white;
        }

        .paste-btn:hover {
            background: #7c3aed;
        }

        /* Language Selector */
        .language-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .language-selector label {
            color: #a8d8ea;
            font-size: 0.9rem;
        }

        select {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.9);
            font-size: 1rem;
            cursor: pointer;
        }

        /* Textarea for input */
        .input-section {
            width: 100%;
            margin-bottom: 20px;
        }

        .textarea-wrapper {
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }

        .textarea-wrapper:focus-within {
            border-color: #a8d8ea;
        }

        textarea {
            width: 100%;
            min-height: 100px;
            max-height: calc(1.5rem * 10 + 30px);
            padding: 15px;
            border: none;
            border-radius: 0;
            background: transparent;
            color: #fff;
            font-family: inherit;
            font-size: 1rem;
            line-height: 1.5rem;
            resize: vertical;
            outline: none;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        textarea::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .input-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .load-btn {
            background: #10B981;
            color: white;
            flex: 1;
        }

        .input-buttons .paste-btn {
            flex: 1;
        }

        /* Canvas Section */
        .canvas-section {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .canvas-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .stroke-control {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #a8d8ea;
        }

        input[type="range"] {
            width: 80px;
        }

        .canvas-container {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        canvas {
            display: block;
            background: #fff;
            touch-action: none;
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            opacity: 0.3;
        }

        .hint {
            margin-top: 15px;
            color: #888;
            font-size: 0.9rem;
        }

        /* Toggle button */
        .toggle-btn {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .toggle-btn.active {
            background: #3B82F6;
            border-color: #3B82F6;
        }

        /* Big Rating Buttons */
        .big-rating-row {
            display: flex;
            gap: 10px;
            width: 100%;
            max-width: 600px;
            margin: 10px auto;
        }

        .big-rating-btn {
            flex: 1;
            padding: 20px 10px;
            font-size: 1.1rem;
            font-weight: bold;
            border: 2px solid transparent;
            border-radius: 12px;
            cursor: pointer;
            color: white;
            transition: opacity 0.15s;
        }

        .big-rating-btn:hover {
            opacity: 0.85;
        }

        .big-rating-1 {
            background: #ef4444;
        }

        .big-rating-2 {
            background: #f59e0b;
        }

        .big-rating-3 {
            background: #22c55e;
        }

        /* Keyboard shortcuts hint */
        .shortcuts-hint {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.8rem;
            color: #888;
        }

        /* Toggle Switch Styles */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider-toggle {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #555;
            transition: .4s;
            border-radius: 26px;
        }

        .slider-toggle:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        input:checked + .slider-toggle {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
        }

        input:checked + .slider-toggle:before {
            transform: translateX(24px);
        }

        .toggle-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toggle-label {
            font-size: 0.85rem;
            color: #a8d8ea;
        }

        /* Dropbox Sidebar Styles */
        .dbx-sidebar {
            position: fixed;
            right: 0;
            top: 0;
            width: 280px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #333;
            z-index: 1001;
            background: #1a1a2e;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .dbx-sidebar.open {
            transform: translateX(0);
        }

        .dbx-sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 10px;
            font-size: 14px;
            font-weight: bold;
            border-bottom: 1px solid #333;
            color: #4da6ff;
        }

        .dbx-sidebar-header button {
            background: transparent;
            border: none;
            color: #888;
            font-size: 18px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .dbx-sidebar-header button:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
        }

        .dbx-sidebar-file-list {
            flex: 1;
            overflow-y: auto;
            padding: 0 5px;
        }

        .dbx-app-key-row {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .dbx-app-key-row input {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 14px;
            outline: none;
        }

        .dbx-app-key-row input:focus {
            border-color: #4da6ff;
        }

        .dbx-app-key-row button {
            padding: 10px 16px;
            background: #0061FF;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
        }

        .dbx-app-key-row button:hover {
            background: #0052d4;
        }

        .dbx-search-row {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .dbx-search-row input {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 14px;
            outline: none;
        }

        .dbx-search-row input:focus {
            border-color: #4da6ff;
        }

        .dbx-search-row button {
            padding: 10px 16px;
            background: #0061FF;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
        }

        .dbx-search-row button:hover {
            background: #0052d4;
        }

        .dbx-result-item.selected {
            background: rgba(77, 166, 255, 0.2);
            border-left: 3px solid #4da6ff;
        }

        .dbx-show-all-btn {
            background: transparent;
            border: none;
            color: #4da6ff;
            font-size: 12px;
            cursor: pointer;
            padding: 4px 8px;
        }

        .dbx-show-all-btn:hover {
            text-decoration: underline;
        }

        .dbx-breadcrumb {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            padding: 6px 10px;
            font-size: 12px;
            color: #888;
            gap: 2px;
        }

        .dbx-breadcrumb-link {
            color: #4da6ff;
            cursor: pointer;
            background: none;
            border: none;
            font-size: 12px;
            padding: 0;
        }

        .dbx-breadcrumb-link:hover {
            text-decoration: underline;
        }

        .dbx-breadcrumb-sep {
            color: #666;
            margin: 0 2px;
        }

        .dbx-result-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .dbx-result-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .dbx-result-icon {
            font-size: 18px;
            flex-shrink: 0;
        }

        .dbx-result-info {
            flex: 1;
            min-width: 0;
        }

        .dbx-result-name {
            font-size: 14px;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .dbx-result-path {
            font-size: 11px;
            color: #888;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .dbx-sign-out-btn {
            width: calc(100% - 20px);
            margin: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: #f87171;
            border: 1px solid rgba(248, 113, 113, 0.3);
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
        }

        .dbx-sign-out-btn:hover {
            background: rgba(248, 113, 113, 0.15);
        }

        .dbx-status {
            font-size: 12px;
            color: #888;
            margin-bottom: 10px;
            min-height: 18px;
        }

        .dbx-save-btn {
            background: #0061FF;
            color: white;
            flex: 1;
        }

        .dbx-save-btn:hover {
            background: #0052d4;
        }
    </style>
</head>
<body>
    <!-- Sidebar -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <span>DOCUMENTS</span>
            <button onclick="toggleSidebar()">&#10005;</button>
        </div>
        <div class="sidebar-access-code" id="accessCodeSection" style="display: none;">
            <input type="text" id="accessCodeInput" placeholder="123" autocomplete="off">
            <span>Access code</span>
        </div>
        <button class="sidebar-new-file-btn" onclick="createNewFile()">+ New File</button>
        <div class="sidebar-file-list" id="fileList">
            <div class="sidebar-no-files">No files yet</div>
        </div>
        <button class="sidebar-refresh-btn" onclick="loadFiles()">Refresh</button>
    </div>

    <!-- Sidebar Toggle Button -->
    <button class="sidebar-toggle-btn" id="sidebarToggle" onclick="toggleSidebar()">&#9776; Files</button>

    <!-- Pagination -->
    <div id="paginationContainer">
        <button class="nav-btn" id="prevBtn">&#9664;</button>
        <span class="counter" id="counterDisplay">0/0</span>
        <button class="nav-btn" id="nextBtn">&#9654;</button>
        <button class="nav-btn" id="resetBtn" title="Go to first card">&#8634;</button>
        <span style="margin: 0 8px; color: rgba(255,255,255,0.3);">|</span>
        <label style="font-size: 12px; color: #a8d8ea; display: flex; align-items: center; gap: 4px;">
            <input type="checkbox" id="filterToggle" style="cursor: pointer;">
            Filter
        </label>
        <span style="margin: 0 8px; color: rgba(255,255,255,0.3);">|</span>
        <span style="font-size: 12px; color: #a8d8ea;">Rate:</span>
        <button class="nav-btn rating-btn" id="rate1Btn" data-rating="1">1 [</button>
        <button class="nav-btn rating-btn" id="rate2Btn" data-rating="2">2 ]</button>
        <button class="nav-btn rating-btn" id="rate3Btn" data-rating="3">3 \</button>
        <span style="margin: 0 8px; color: rgba(255,255,255,0.3);">|</span>
        <button class="nav-btn" id="dropboxBtn" title="Dropbox" style="font-size: 12px; font-weight: bold;">DB</button>
    </div>

    <!-- Dropbox Sidebar -->
    <div class="dbx-sidebar" id="dbxSidebar">
        <div class="dbx-sidebar-header">
            <span>DROPBOX</span>
            <button id="dbxCloseBtn">&#10005;</button>
        </div>
        <!-- Sign-in (shown when not authenticated) -->
        <div id="dbxSignInSection" style="padding: 15px;">
            <div class="dbx-app-key-row" id="dbxAppKeyRow" style="display: none;">
                <input type="text" id="dbxAppKeyInput" placeholder="Dropbox App Key">
            </div>
            <div class="dbx-app-key-row">
                <button id="dbxSignInBtn" style="flex: 1;">Sign In</button>
            </div>
        </div>
        <!-- File browsing (shown when authenticated) -->
        <div id="dbxSearchSection" style="display: none; flex-direction: column; flex: 1; overflow: hidden;">
            <div class="dbx-status" id="dbxStatus" style="padding: 5px 10px 0;"></div>
            <div class="dbx-search-row" style="padding: 5px 10px 10px;">
                <input type="text" id="dbxSearchInput" placeholder="Search files...">
                <button id="dbxSearchBtn">Go</button>
            </div>
            <div class="dbx-breadcrumb" id="dbxBreadcrumb"></div>
            <div class="dbx-sidebar-file-list" id="dbxResults"></div>
            <button id="dbxSignOutBtn" class="dbx-sign-out-btn">Sign Out</button>
        </div>
    </div>

    <div class="main-content">
        <h1>Language Study Flashcards Loader</h1>
        <p style="font-size: 0.75rem; color: #666; margin: 0 0 10px 0;">Back and Next & Speak only speak when Auto Reveal is on</p>

        <!-- Language Selector & Controls -->
        <div class="language-selector">
            <label>Language:</label>
            <select id="languageSelect">
                <option value="zh-CN">Mandarin</option>
                <option value="zh-HK">Cantonese</option>
                <option value="en-US">English</option>
                <option value="es-ES">Spanish</option>
                <option value="fr-FR">French</option>
            </select>
            <select id="speechRate">
                <option value="0.7">0.7x</option>
                <option value="1" selected>1x</option>
            </select>
            <div class="toggle-group">
                <label class="switch">
                    <input type="checkbox" id="autoRevealToggle">
                    <span class="slider-toggle"></span>
                </label>
                <span class="toggle-label" id="autoRevealLabel">Auto Reveal</span>
            </div>
            <button class="speak-btn" id="speakRevealBtn">Back</button>
            <button class="speak-btn" id="nextSpeakBtn">Next & Speak</button>
        </div>

        <!-- Flashcard Section -->
        <div class="flashcard-container" id="flashcardSection">
            <div class="flashcard" id="flashcard">
                <div class="chinese-text" id="chineseText">Load flashcards to begin</div>
                <div class="english-text" id="englishText"></div>
                <p class="tap-hint" id="tapHint">Tap card for next, auto reveal on will speak only</p>
            </div>
        </div>

        <!-- Big Rating Buttons -->
        <div class="big-rating-row">
            <button class="big-rating-btn big-rating-1" id="bigRate1Btn">1 Daily</button>
            <button class="big-rating-btn big-rating-2" id="bigRate2Btn">2 Two Days</button>
            <button class="big-rating-btn big-rating-3" id="bigRate3Btn">3 Mastered</button>
        </div>

        <!-- Canvas Section (always visible below flashcard) -->
        <div class="canvas-section" id="canvasSection">
            <div class="canvas-controls">
                <button class="clear-btn" onclick="clearCanvas()">Clear</button>
                <button class="dark-btn" onclick="toggleDarkCanvas()">Dark</button>
                <button class="grid-btn" onclick="toggleGrid()">Grid</button>
                <button class="expand-btn" id="expandBtn" onclick="toggleExpandCanvas()">Expand</button>
                <div class="stroke-control">
                    <label>Stroke:</label>
                    <input type="range" id="strokeSize" min="2" max="20" value="2" onchange="updateStroke()">
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="drawCanvas"></canvas>
                <canvas id="gridCanvas" class="grid-overlay"></canvas>
            </div>
        </div>

        <!-- Input Section -->
        <div class="input-section" id="inputSection">
            <div class="textarea-wrapper">
                <textarea id="inputTextarea" placeholder='Paste content here. Separate cards with blank lines.

Format (with SRS):
YYYY-MM-DD (optional date, first line)

Chinese text // 1 (rating: 1=daily, 2=2days, 3=mastered)
English text (back)

Example:
"""
2025-02-05

每天读圣经 // 1
Read the Bible every day

圣经是我们信仰的基础 // 2
The Bible is the foundation of our faith
"""'></textarea>
            </div>
            <div style="margin-top: 10px; display: flex; align-items: center; gap: 10px;">
                <label style="color: #a8d8ea; font-size: 0.9rem;">Mode:</label>
                <select id="parseMode" style="padding: 8px 12px; border: none; border-radius: 6px; background: rgba(255, 255, 255, 0.9); font-size: 1rem; cursor: pointer;">
                    <option value="chinese-english">Chinese → English</option>
                    <option value="line-memorize">Memorization (English only line-by-line)</option>
                </select>
            </div>
            <div class="input-buttons">
                <button class="paste-btn" id="pasteBtn">Paste from Clipboard</button>
                <button class="load-btn" id="loadBtn">Load Flashcards</button>
                <button class="save-file-btn" id="saveFileBtn" style="background: #3B82F6; color: white; flex: 1;">&#128190; Save File</button>
                <button class="dbx-save-btn" id="dbxSaveBtn" style="display: none;">Save Textarea &#8593; DB</button>
                <button class="save-file-btn" id="updateTextareaBtn" style="background: #8b5cf6; color: white; flex: 1;">&#8635; Update Textarea</button>
                <button class="save-file-btn" id="resetRatingsBtn" style="background: #ef4444; color: white; flex: 1;">Reset Ratings to 1</button>
            </div>
        </div>
    </div>

    <div class="shortcuts-hint">
        Arrow keys / Click card: Navigate | Space: Back | S/ArrowUp: Speak | [ ] \: Rate card ([:daily, ]:2days, \:mastered) &amp; next | 1-9,0: Go to card #
    </div>

    <script>
        // ============ DROPBOX INTEGRATION ============
        let dropboxAccessToken = null;
        let dropboxAppKey = '';
        let currentDropboxFilePath = '';
        let currentDropboxFileName = '';
        let dbxRootFilesLoaded = false;

        const isLocalhost = ['localhost', '127.0.0.1'].includes(window.location.hostname);

        // PKCE helpers
        function generateCodeVerifier() {
            const array = new Uint8Array(64);
            crypto.getRandomValues(array);
            return btoa(String.fromCharCode(...array))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=+$/, '');
        }

        async function generateCodeChallenge(verifier) {
            const encoder = new TextEncoder();
            const data = encoder.encode(verifier);
            const digest = await crypto.subtle.digest('SHA-256', data);
            return btoa(String.fromCharCode(...new Uint8Array(digest)))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=+$/, '');
        }

        async function fetchDropboxAppKey() {
            if (isLocalhost) {
                return localStorage.getItem('dropbox-app-key') || '';
            }
            try {
                const res = await fetch('/api/dropbox-key');
                const data = await res.json();
                return data.key || '';
            } catch {
                return '';
            }
        }

        async function toggleDropboxSidebar() {
            const sidebar = document.getElementById('dbxSidebar');
            sidebar.classList.toggle('open');

            if (!sidebar.classList.contains('open')) return;

            // Show input only on localhost
            if (isLocalhost) {
                document.getElementById('dbxAppKeyRow').style.display = 'flex';
                const savedKey = localStorage.getItem('dropbox-app-key');
                if (savedKey) {
                    document.getElementById('dbxAppKeyInput').value = savedKey;
                }
            } else {
                document.getElementById('dbxAppKeyRow').style.display = 'none';
            }
            // Show correct section based on auth state
            if (dropboxAccessToken) {
                document.getElementById('dbxSignInSection').style.display = 'none';
                document.getElementById('dbxSearchSection').style.display = 'flex';
                // Auto-load root folder on first open
                if (!dbxRootFilesLoaded) {
                    dbxRootFilesLoaded = true;
                    loadDropboxFolder('');
                }
            } else {
                document.getElementById('dbxSignInSection').style.display = 'block';
                document.getElementById('dbxSearchSection').style.display = 'none';
            }
        }

        function closeDropboxSidebar() {
            document.getElementById('dbxSidebar').classList.remove('open');
        }

        function setDbxStatus(msg) {
            document.getElementById('dbxStatus').textContent = msg;
        }

        async function handleDropboxSignIn() {
            let appKey;
            if (isLocalhost) {
                appKey = document.getElementById('dbxAppKeyInput').value.trim();
                if (!appKey) {
                    alert('Please enter a Dropbox App Key');
                    return;
                }
                localStorage.setItem('dropbox-app-key', appKey);
            } else {
                appKey = await fetchDropboxAppKey();
                if (!appKey) {
                    alert('Dropbox App Key not configured on server');
                    return;
                }
            }
            dropboxAppKey = appKey;

            const verifier = generateCodeVerifier();
            const challenge = await generateCodeChallenge(verifier);
            sessionStorage.setItem('dropbox_code_verifier', verifier);

            const redirectUri = window.location.origin + window.location.pathname;
            const authUrl = `https://www.dropbox.com/oauth2/authorize?client_id=${appKey}&response_type=code&code_challenge=${challenge}&code_challenge_method=S256&redirect_uri=${encodeURIComponent(redirectUri)}&token_access_type=online`;
            window.location.href = authUrl;
        }

        async function handleDropboxOAuthRedirect() {
            const params = new URLSearchParams(window.location.search);
            const code = params.get('code');
            if (!code) return;

            const verifier = sessionStorage.getItem('dropbox_code_verifier');
            const appKey = await fetchDropboxAppKey();
            if (!verifier || !appKey) return;
            dropboxAppKey = appKey;

            const redirectUri = window.location.origin + window.location.pathname;
            const body = new URLSearchParams({
                code,
                grant_type: 'authorization_code',
                client_id: appKey,
                redirect_uri: redirectUri,
                code_verifier: verifier,
            });

            try {
                const res = await fetch('https://api.dropboxapi.com/oauth2/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: body.toString(),
                });
                const data = await res.json();
                if (data.access_token) {
                    dropboxAccessToken = data.access_token;
                    sessionStorage.removeItem('dropbox_code_verifier');
                    // Clean URL
                    window.history.replaceState({}, document.title, window.location.pathname);
                    // Auto-open sidebar in signed-in state
                    toggleDropboxSidebar();
                } else {
                    console.error('Dropbox auth failed:', data);
                }
            } catch (err) {
                console.error('Dropbox auth error:', err);
            }
        }

        async function handleDropboxSignOut() {
            if (dropboxAccessToken) {
                try {
                    await fetch('https://api.dropboxapi.com/2/auth/token/revoke', {
                        method: 'POST',
                        headers: { Authorization: `Bearer ${dropboxAccessToken}` },
                    });
                } catch { /* ignore */ }
            }
            dropboxAccessToken = null;
            currentDropboxFilePath = '';
            currentDropboxFileName = '';
            dbxRootFilesLoaded = false;
            document.getElementById('dbxSaveBtn').style.display = 'none';
            document.getElementById('saveFileBtn').style.display = '';
            document.getElementById('dbxSignInSection').style.display = 'block';
            document.getElementById('dbxSearchSection').style.display = 'none';
            document.getElementById('dbxResults').innerHTML = '';
            document.getElementById('dbxBreadcrumb').innerHTML = '';
            setDbxStatus('Signed out');
        }

        async function searchDropboxFiles(query) {
            if (!query.trim() || !dropboxAccessToken) return;
            setDbxStatus('Searching...');
            document.getElementById('dbxBreadcrumb').innerHTML = '';

            try {
                const response = await fetch('https://api.dropboxapi.com/2/files/search_v2', {
                    method: 'POST',
                    headers: {
                        Authorization: `Bearer ${dropboxAccessToken}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        query: query,
                        options: { max_results: 20 },
                    }),
                });
                if (!response.ok) throw new Error('Search failed');
                const data = await response.json();
                const results = (data.matches || []).map(m => {
                    const metadata = m.metadata?.metadata || m.metadata;
                    return {
                        name: metadata.name,
                        path: metadata.path_lower || metadata.path_display,
                        isFolder: metadata['.tag'] === 'folder',
                    };
                }).filter(item => !item.isFolder);
                setDbxStatus(`Found ${results.length} files`);
                renderDbxResults(results, true);
            } catch (error) {
                setDbxStatus('Error: ' + error.message);
            }
        }

        async function loadDropboxFolder(path) {
            setDbxStatus('Loading folder...');
            try {
                const response = await fetch('https://api.dropboxapi.com/2/files/list_folder', {
                    method: 'POST',
                    headers: {
                        Authorization: `Bearer ${dropboxAccessToken}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ path: path }),
                });
                if (!response.ok) throw new Error('Failed to list folder');
                const data = await response.json();
                const entries = (data.entries || []).map(entry => ({
                    name: entry.name,
                    path: entry.path_lower || entry.path_display,
                    isFolder: entry['.tag'] === 'folder',
                }));
                // Sort: folders first, then files, alphabetically
                entries.sort((a, b) => {
                    if (a.isFolder !== b.isFolder) return a.isFolder ? -1 : 1;
                    return a.name.localeCompare(b.name);
                });
                setDbxStatus(`Loaded ${entries.length} items`);
                renderDbxBreadcrumb(path);
                renderDbxResults(entries);
            } catch (error) {
                setDbxStatus('Error: ' + error.message);
            }
        }

        function renderDbxBreadcrumb(path) {
            const container = document.getElementById('dbxBreadcrumb');
            if (!path) {
                container.innerHTML = '';
                return;
            }
            const parts = path.replace(/^\//, '').split('/').filter(Boolean);
            let html = '';
            parts.forEach((part, i) => {
                const crumbPath = '/' + parts.slice(0, i + 1).join('/');
                if (i > 0) html += '<span class="dbx-breadcrumb-sep">/</span>';
                html += `<button class="dbx-breadcrumb-link" data-path="${crumbPath}">${part}</button>`;
            });
            container.innerHTML = html;
        }

        async function loadDropboxFile(path, name) {
            setDbxStatus(`Loading ${name}...`);
            try {
                const response = await fetch('https://content.dropboxapi.com/2/files/download', {
                    method: 'POST',
                    headers: {
                        Authorization: `Bearer ${dropboxAccessToken}`,
                        'Dropbox-API-Arg': JSON.stringify({ path: path }),
                    },
                });
                if (!response.ok) throw new Error('Download failed');
                const content = await response.text();

                // Load into textarea
                const textarea = document.getElementById('inputTextarea');
                textarea.value = content;
                loadFlashcards();

                // Track for saving back
                currentDropboxFilePath = path;
                currentDropboxFileName = name;

                // Show DB save button, hide local save button
                document.getElementById('dbxSaveBtn').style.display = 'flex';
                document.getElementById('saveFileBtn').style.display = 'none';

                // Highlight the loaded file in sidebar
                document.querySelectorAll('#dbxResults .dbx-result-item').forEach(el => {
                    el.classList.toggle('selected', el.dataset.path === path);
                });
                setDbxStatus(`Loaded: ${name}`);
            } catch (error) {
                setDbxStatus('Error: ' + error.message);
            }
        }

        async function saveToDropbox() {
            if (!currentDropboxFilePath || !dropboxAccessToken) return;

            const btn = document.getElementById('dbxSaveBtn');
            const origText = btn.textContent;
            btn.textContent = 'Saving...';
            btn.disabled = true;

            try {
                // Use textarea content directly (matches vercel_dropbox behavior)
                const textarea = document.getElementById('inputTextarea');
                const content = textarea.value;

                const response = await fetch('https://content.dropboxapi.com/2/files/upload', {
                    method: 'POST',
                    headers: {
                        Authorization: `Bearer ${dropboxAccessToken}`,
                        'Dropbox-API-Arg': JSON.stringify({
                            path: currentDropboxFilePath,
                            mode: { '.tag': 'overwrite' },
                            mute: true,
                        }),
                        'Content-Type': 'application/octet-stream',
                    },
                    body: content,
                });
                if (response.ok) {
                    btn.textContent = 'Saved!';
                    setTimeout(() => { btn.textContent = origText; }, 1500);
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error_summary || `HTTP ${response.status}`);
                }
            } catch (error) {
                alert('Error saving to Dropbox: ' + error.message);
                btn.textContent = origText;
            } finally {
                btn.disabled = false;
            }
        }

        function renderDbxResults(items, isSearch) {
            const container = document.getElementById('dbxResults');
            if (items.length === 0) {
                container.innerHTML = '<div style="padding: 15px; color: #888; text-align: center;">No results</div>';
                return;
            }
            let html = '';
            if (isSearch) {
                html += '<div style="padding: 2px 10px;"><button class="dbx-show-all-btn" id="dbxShowAllBtn">Show All</button></div>';
            }
            html += items.map(item => {
                const icon = item.isFolder ? '\uD83D\uDCC1' : '\uD83D\uDCC4';
                const isSelected = !item.isFolder && currentDropboxFilePath && item.path === currentDropboxFilePath;
                const pathHtml = isSearch ? `<div class="dbx-result-path">${item.path}</div>` : '';
                return `
                    <div class="dbx-result-item${isSelected ? ' selected' : ''}" data-path="${item.path}" data-name="${item.name}" data-folder="${item.isFolder}">
                        <span class="dbx-result-icon">${icon}</span>
                        <div class="dbx-result-info">
                            <div class="dbx-result-name">${item.name}</div>
                            ${pathHtml}
                        </div>
                    </div>
                `;
            }).join('');
            container.innerHTML = html;
        }

        function handleDbxResultClick(e) {
            // Handle "Show All" button
            if (e.target.id === 'dbxShowAllBtn') {
                document.getElementById('dbxSearchInput').value = '';
                document.getElementById('dbxBreadcrumb').innerHTML = '';
                loadDropboxFolder('');
                return;
            }
            // Handle breadcrumb clicks
            if (e.target.closest('.dbx-breadcrumb-link')) {
                const crumbPath = e.target.dataset.path;
                loadDropboxFolder(crumbPath);
                return;
            }
            const item = e.target.closest('.dbx-result-item');
            if (!item) return;
            const path = item.dataset.path;
            const name = item.dataset.name;
            const isFolder = item.dataset.folder === 'true';
            if (isFolder) {
                loadDropboxFolder(path);
            } else {
                loadDropboxFile(path, name);
            }
        }

        function handleDbxSearch() {
            const query = document.getElementById('dbxSearchInput').value.trim();
            if (!query) {
                loadDropboxFolder('');
                return;
            }
            // Direct path navigation
            if (query.startsWith('/')) {
                const path = query.replace(/\/+$/, '') || '';
                loadDropboxFolder(path);
                return;
            }
            searchDropboxFiles(query);
        }

        // ============ SIDEBAR & FILE MANAGEMENT ============
        let files = {};
        let selectedFile = null;
        let editingFileName = null;
        let newFileName = '';

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const toggleBtn = document.getElementById('sidebarToggle');
            sidebar.classList.toggle('open');
            if (sidebar.classList.contains('open')) {
                toggleBtn.innerHTML = '&#9664; Hide';
            } else {
                toggleBtn.innerHTML = '&#9776; Files';
            }
        }

        async function loadFiles() {
            try {
                if (isLocalhost) {
                    const storedFiles = localStorage.getItem('flashcard-files');
                    files = storedFiles ? JSON.parse(storedFiles) : {};
                } else {
                    const response = await fetch('/api/files');
                    if (response.ok) {
                        const data = await response.json();
                        files = data.files || {};
                    }
                }
                renderFileList();
            } catch (err) {
                console.error('Error loading files:', err);
            }
        }

        function renderFileList() {
            const fileListEl = document.getElementById('fileList');
            const filenames = Object.keys(files).sort();

            if (filenames.length === 0) {
                fileListEl.innerHTML = '<div class="sidebar-no-files">No files yet</div>';
                return;
            }

            fileListEl.innerHTML = filenames.map(filename => {
                const isSelected = selectedFile === filename;
                const isEditing = editingFileName === filename;

                if (isEditing) {
                    return `
                        <div class="sidebar-file-item ${isSelected ? 'selected' : ''}">
                            <input type="text" class="sidebar-rename-input" id="renameInput" value="${filename}" onkeypress="if(event.key==='Enter')confirmRename()">
                            <button class="sidebar-rename-confirm" onclick="confirmRename()">&#10003;</button>
                            <button class="sidebar-rename-cancel" onclick="cancelRename()">&#10005;</button>
                        </div>
                    `;
                }

                return `
                    <div class="sidebar-file-item ${isSelected ? 'selected' : ''}" onclick="selectFile('${filename}')">
                        <span class="sidebar-file-name">${filename}</span>
                        <div class="sidebar-file-actions" onclick="event.stopPropagation()">
                            <button class="sidebar-edit-btn" onclick="startRenameFile('${filename}')" title="Rename">&#9998;</button>
                            <button class="sidebar-delete-btn" onclick="deleteFile('${filename}')" title="Delete">&#128465;</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function createNewFile() {
            const filename = prompt('Enter filename (e.g., lesson1.txt):');
            if (!filename) return;

            let finalName = filename;
            if (!finalName.includes('.')) {
                finalName += '.txt';
            }

            if (files[finalName]) {
                alert('File already exists!');
                return;
            }

            // Get current textarea content
            const textarea = document.getElementById('inputTextarea');
            const content = textarea.value.trim() || '';

            files[finalName] = content;
            if (isLocalhost) {
                localStorage.setItem('flashcard-files', JSON.stringify(files));
            }
            selectedFile = finalName;
            renderFileList();
        }

        function selectFile(filename) {
            selectedFile = filename;
            const fileData = files[filename] || '';

            let content = '';
            let mode = 'chinese-english'; // default

            // Try to parse as JSON (new format with mode)
            try {
                const parsed = JSON.parse(fileData);
                if (parsed.mode && parsed.content !== undefined) {
                    mode = parsed.mode;
                    content = parsed.content;
                } else {
                    // Not our JSON format, treat as plain text
                    content = fileData;
                }
            } catch (e) {
                // Not JSON, treat as plain text (backward compatibility)
                content = fileData;
            }

            // Set the parse mode dropdown
            document.getElementById('parseMode').value = mode;

            // Load content into textarea
            const textarea = document.getElementById('inputTextarea');
            textarea.value = content;


            // Parse and display flashcards
            loadFlashcards();

            renderFileList();
        }

        function getContentToSave() {
            // If we have loaded flashcards, reconstruct content from allCards
            if (allCards.length > 0) {
                const parseMode = document.getElementById('parseMode').value;

                if (parseMode === 'line-memorize') {
                    // Save each card's chinese text as a separate line
                    return allCards.map(card => card.chinese).join('\n');
                } else {
                    // Save as Chinese/English pairs separated by blank lines
                    return allCards.map(card => {
                        if (card.english) {
                            return `${card.chinese}\n${card.english}`;
                        } else {
                            return card.chinese;
                        }
                    }).join('\n\n');
                }
            }

            // Fallback to textarea content if no cards loaded
            const textarea = document.getElementById('inputTextarea');
            return textarea.value.trim();
        }

        async function saveCurrentFile() {
            const content = getContentToSave();

            if (!content) {
                alert('No content to save! Load flashcards first.');
                return;
            }

            if (!selectedFile) {
                const filename = prompt('Enter filename (e.g., lesson1.txt):');
                if (!filename) return;

                let finalName = filename;
                if (!finalName.includes('.')) {
                    finalName += '.txt';
                }
                selectedFile = finalName;
            }

            // Save as JSON with mode and content
            const mode = document.getElementById('parseMode').value;
            const fileData = JSON.stringify({ mode: mode, content: content });

            await saveFile(selectedFile, fileData);

            // Also update textarea to show what was saved
            const textarea = document.getElementById('inputTextarea');
            textarea.value = content;

        }

        async function saveFile(filename, content) {
            try {
                if (isLocalhost) {
                    files[filename] = content;
                    localStorage.setItem('flashcard-files', JSON.stringify(files));
                    alert('File saved locally!');
                } else {
                    const accessCode = document.getElementById('accessCodeInput').value.trim();
                    if (accessCode !== '123') {
                        alert('Please enter access code "123" to save');
                        return;
                    }

                    const response = await fetch('/api/files', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            filename: filename,
                            content: content,
                            accessCode: accessCode,
                        }),
                    });

                    if (response.ok) {
                        files[filename] = content;
                        alert('File saved!');
                    } else {
                        const data = await response.json();
                        alert('Error saving: ' + (data.error || 'Unknown error'));
                    }
                }
                renderFileList();
            } catch (err) {
                console.error('Error saving file:', err);
                alert('Error saving file');
            }
        }

        async function deleteFile(filename) {
            if (!confirm(`Delete "${filename}"?`)) return;

            try {
                if (isLocalhost) {
                    delete files[filename];
                    localStorage.setItem('flashcard-files', JSON.stringify(files));
                    if (selectedFile === filename) {
                        selectedFile = null;
                    }
                } else {
                    const accessCode = document.getElementById('accessCodeInput').value.trim();
                    if (accessCode !== '123') {
                        alert('Please enter access code "123" to delete');
                        return;
                    }

                    const response = await fetch(`/api/files?filename=${encodeURIComponent(filename)}`, {
                        method: 'DELETE',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ accessCode: accessCode }),
                    });

                    if (response.ok) {
                        delete files[filename];
                        if (selectedFile === filename) {
                            selectedFile = null;
                        }
                    } else {
                        alert('Error deleting file');
                        return;
                    }
                }
                renderFileList();
            } catch (err) {
                console.error('Error deleting file:', err);
                alert('Error deleting file');
            }
        }

        function startRenameFile(filename) {
            editingFileName = filename;
            newFileName = filename;
            renderFileList();
            setTimeout(() => {
                const input = document.getElementById('renameInput');
                if (input) input.focus();
            }, 0);
        }

        function cancelRename() {
            editingFileName = null;
            newFileName = '';
            renderFileList();
        }

        async function confirmRename() {
            const input = document.getElementById('renameInput');
            const newName = input ? input.value.trim() : '';

            if (!newName || newName === editingFileName) {
                cancelRename();
                return;
            }

            if (files[newName]) {
                alert('A file with this name already exists!');
                return;
            }

            if (!isLocalhost) {
                const accessCode = document.getElementById('accessCodeInput').value.trim();
                if (accessCode !== '123') {
                    alert('Please enter access code "123" to rename');
                    return;
                }
            }

            const content = files[editingFileName];

            if (isLocalhost) {
                delete files[editingFileName];
                files[newName] = content;
                localStorage.setItem('flashcard-files', JSON.stringify(files));
                if (selectedFile === editingFileName) {
                    selectedFile = newName;
                }
            } else {
                await saveFile(newName, content);
                await deleteFile(editingFileName);
                selectedFile = newName;
            }

            editingFileName = null;
            newFileName = '';
            renderFileList();
        }

        // ============ FLASHCARD DATA & STATE ============
        let allCards = [];
        let allCardsUnfiltered = []; // Store all cards before filtering
        let currentIndex = 0;
        let isRevealed = false;
        let autoReveal = false;
        let digitBuffer = '';
        let digitTimeout = null;
        // Per-card dates: each card has its own ratedDate field
        let filterEnabled = false; // Filter toggle state

        // Sample data - will be replaced when user loads content
        // Format: Chinese text (front) followed by English text (back)
        // Cards separated by blank lines
        const sampleData = `"""
每天读圣经；
Read the Bible every day

圣经是我们信仰的基础；
The Bible is the foundation of our faith

圣经是神启示给我们的话语
The Bible is God's word revealed to us

我们要常常祷告
We should pray often

神爱世人
God loves the world
"""`;

        // ============ PARSING FUNCTIONS ============
        function parseFlashcards(text) {
            const parseMode = document.getElementById('parseMode').value;

            if (parseMode === 'line-memorize') {
                return parseLineMemorization(text);
            } else {
                return parseChineseEnglish(text);
            }
        }

        function parseLineMemorization(text) {
            const cards = [];

            // Remove leading/trailing """ if present
            let cleanText = text.trim();
            if (cleanText.startsWith('"""')) {
                cleanText = cleanText.substring(3);
            }
            if (cleanText.endsWith('"""')) {
                cleanText = cleanText.substring(0, cleanText.length - 3);
            }

            // Split by newlines and filter out empty lines, ".." lines, and standalone date lines
            const lines = cleanText.split('\n');
            const cardLines = lines
                .map(line => line.trim())
                .filter(line => line && line !== '..' && !line.match(/^\d{4}-\d{2}-\d{2}$/));

            cardLines.forEach(line => {
                let text = line;
                let rating = 1; // Default rating
                let ratedDate = null;

                // Check for rating + optional date (e.g., "每天读圣经 // 3 // 2026-02-19")
                const ratingMatch = text.match(/\s*\/\/\s*(\d+)(?:\s*\/\/\s*(\d{4}-\d{2}-\d{2}))?\s*$/);
                if (ratingMatch) {
                    rating = parseInt(ratingMatch[1], 10);
                    if (ratingMatch[2]) {
                        ratedDate = ratingMatch[2];
                    }
                    // Remove rating and date from display text
                    text = text.replace(/\s*\/\/\s*\d+(?:\s*\/\/\s*\d{4}-\d{2}-\d{2})?\s*$/, '').trim();
                }

                cards.push({
                    chinese: text,
                    english: '',
                    rating: rating,
                    ratedDate: ratedDate
                });
            });

            return cards;
        }

        function parseChineseEnglish(text) {
            const cards = [];

            // Remove leading/trailing """ if present
            let cleanText = text.trim();
            if (cleanText.startsWith('"""')) {
                cleanText = cleanText.substring(3);
            }
            if (cleanText.endsWith('"""')) {
                cleanText = cleanText.substring(0, cleanText.length - 3);
            }

            // Remove standalone date line from first line (backward compat with old format)
            const lines = cleanText.split('\n');
            if (lines.length > 0 && lines[0].trim().match(/^\d{4}-\d{2}-\d{2}$/)) {
                cleanText = lines.slice(1).join('\n').trim();
            }

            // Split by double newlines (blank lines) to get each card
            const segments = cleanText.split(/\n\s*\n+/).filter(s => s.trim());

            segments.forEach(segment => {
                const segLines = segment.trim().split('\n').filter(line => line.trim());

                if (segLines.length >= 1) {
                    // First line = front of card
                    let front = segLines[0].trim().replace(/[；;]$/, ''); // Remove trailing semicolon
                    let rating = 1; // Default rating
                    let ratedDate = null;

                    // Check for rating + optional date (e.g., "黄金福州鱼丸 // 3 // 2026-02-19")
                    const ratingMatch = front.match(/\s*\/\/\s*(\d+)(?:\s*\/\/\s*(\d{4}-\d{2}-\d{2}))?\s*$/);
                    if (ratingMatch) {
                        rating = parseInt(ratingMatch[1], 10);
                        if (ratingMatch[2]) {
                            ratedDate = ratingMatch[2];
                        }
                        // Remove rating and date from display text
                        front = front.replace(/\s*\/\/\s*\d+(?:\s*\/\/\s*\d{4}-\d{2}-\d{2})?\s*$/, '').trim();
                    }

                    // Second line (if exists) = back of card
                    const back = segLines.length >= 2 ? segLines.slice(1).join(' ').trim() : '';

                    cards.push({
                        chinese: front,
                        english: back,
                        rating: rating,
                        ratedDate: ratedDate
                    });
                }
            });

            return cards;
        }

        // ============ UI UPDATE FUNCTIONS ============
        function updateDisplay() {
            const chineseText = document.getElementById('chineseText');
            const englishText = document.getElementById('englishText');
            const counterDisplay = document.getElementById('counterDisplay');
            const tapHint = document.getElementById('tapHint');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');

            if (allCards.length === 0) {
                chineseText.textContent = 'No flashcards loaded';
                englishText.textContent = '';
                counterDisplay.textContent = '0/0';
                prevBtn.disabled = true;
                nextBtn.disabled = true;

                // Clear rating button highlights
                document.querySelectorAll('.rating-btn').forEach(btn => btn.classList.remove('active'));
                return;
            }

            const card = allCards[currentIndex];
            chineseText.textContent = card.chinese;
            englishText.textContent = card.english;
            counterDisplay.textContent = `${currentIndex + 1}/${allCards.length}`;

            // Check auto-reveal toggle
            if (autoReveal) {
                // Auto-reveal is ON: show English immediately
                isRevealed = true;
                englishText.classList.add('revealed');
                tapHint.classList.add('hidden');
            } else {
                // Auto-reveal is OFF: hide English
                isRevealed = false;
                englishText.classList.remove('revealed');
                tapHint.classList.remove('hidden');
            }

            // Update nav buttons
            prevBtn.disabled = currentIndex === 0;
            nextBtn.disabled = currentIndex === allCards.length - 1;

            // Highlight current card's rating
            const rating = card.rating || 1;
            document.querySelectorAll('.rating-btn').forEach(btn => {
                const btnRating = parseInt(btn.dataset.rating, 10);
                if (btnRating === rating) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        function handleFlashcardClick() {
            if (autoReveal) {
                // Auto Reveal ON: speak only, don't navigate
                speakChinese();
            } else {
                // Auto Reveal OFF: just go next
                navigate(1);
            }
        }

        function goBackAndSpeak() {
            // Go back one card
            navigate(-1);
            // Only speak if Auto Reveal is on
            if (autoReveal) {
                speakChinese();
            }
        }

        function nextAndSpeak() {
            // Go to next card
            navigate(1);
            // Only speak if Auto Reveal is on
            if (autoReveal) {
                speakChinese();
            }
        }

        function revealEnglish() {
            const englishText = document.getElementById('englishText');
            const tapHint = document.getElementById('tapHint');

            if (!isRevealed) {
                isRevealed = true;
                englishText.classList.add('revealed');
                tapHint.classList.add('hidden');
            } else {
                isRevealed = false;
                englishText.classList.remove('revealed');
                tapHint.classList.remove('hidden');
            }
        }

        function navigate(direction) {
            const newIndex = currentIndex + direction;
            if (newIndex >= 0 && newIndex < allCards.length) {
                currentIndex = newIndex;
                updateDisplay();
            }
        }

        function goToCard(cardNumber) {
            if (allCards.length === 0) return;
            if (cardNumber < 1 || cardNumber > allCards.length) {
                console.warn('Invalid card number:', cardNumber, '(valid: 1-' + allCards.length + ')');
                return;
            }
            currentIndex = cardNumber - 1;
            updateDisplay();
            if (autoReveal) {
                speakChinese();
            }
        }

        function handleDigitInput(digit) {
            digitBuffer += digit;
            // Show accumulating digits in the counter display
            document.getElementById('counterDisplay').textContent = digitBuffer + '/' + allCards.length;
            // Reset the timeout on each new digit
            if (digitTimeout) clearTimeout(digitTimeout);
            digitTimeout = setTimeout(() => {
                const num = parseInt(digitBuffer, 10);
                digitBuffer = '';
                digitTimeout = null;
                if (num > 0) {
                    goToCard(num);
                } else {
                    updateDisplay(); // restore counter
                }
            }, 700);
        }

        function loadFlashcards() {
            const textarea = document.getElementById('inputTextarea');
            const text = textarea.value.trim() || sampleData;

            allCardsUnfiltered = parseFlashcards(text);
            applyFilter();
            currentIndex = 0;
            updateDisplay();
        }

        // ============ SRS FILTER & RATING ============
        function applyFilter() {
            if (!filterEnabled) {
                // Filter OFF: show all cards
                allCards = [...allCardsUnfiltered];
                return;
            }

            // Filter ON: show only due cards based on per-card ratedDate
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            allCards = allCardsUnfiltered.filter(card => {
                const rating = card.rating || 1;

                // Rating 3 = mastered, don't show
                if (rating === 3) return false;

                // Use per-card ratedDate, or treat as 7 days ago if missing
                let cardDateObj;
                if (card.ratedDate) {
                    cardDateObj = new Date(card.ratedDate);
                    cardDateObj.setHours(0, 0, 0, 0);
                } else {
                    cardDateObj = new Date(today);
                    cardDateObj.setDate(cardDateObj.getDate() - 7);
                }

                // Calculate days since card was rated
                const daysSince = Math.floor((today - cardDateObj) / (1000 * 60 * 60 * 24));

                // Rating 1: show if 1+ days
                if (rating === 1) return daysSince >= 1;

                // Rating 2: show if 2+ days
                if (rating === 2) return daysSince >= 2;

                return false;
            });
        }

        function toggleFilter() {
            filterEnabled = !filterEnabled;

            // Reset to first card when toggling filter
            currentIndex = 0;

            applyFilter();
            updateDisplay();
        }

        function rateCard(rating) {
            if (allCards.length === 0) return;

            const currentCard = allCards[currentIndex];
            currentCard.rating = rating;
            currentCard.ratedDate = new Date().toISOString().split('T')[0];

            // Also update in unfiltered array
            const unfilteredCard = allCardsUnfiltered.find(c =>
                c.chinese === currentCard.chinese && c.english === currentCard.english
            );
            if (unfilteredCard) {
                unfilteredCard.rating = rating;
                unfilteredCard.ratedDate = currentCard.ratedDate;
            }

            updateDisplay();
        }

        function resetAllRatings() {
            allCardsUnfiltered.forEach(card => { card.rating = 1; card.ratedDate = null; });
            allCards.forEach(card => { card.rating = 1; card.ratedDate = null; });
            updateDisplay();
        }

        function updateTextarea() {
            const textarea = document.getElementById('inputTextarea');
            const parseMode = document.getElementById('parseMode').value;

            let content = '';

            if (parseMode === 'line-memorize') {
                // Line memorization mode: just the Chinese text with per-card dates
                content = allCardsUnfiltered.map(card => {
                    const rating = card.rating || 1;
                    const dateSuffix = card.ratedDate ? ` // ${card.ratedDate}` : '';
                    return `${card.chinese} // ${rating}${dateSuffix}`;
                }).join('\n');
            } else {
                // Chinese-English mode: pairs separated by blank lines with per-card dates
                content = allCardsUnfiltered.map(card => {
                    const rating = card.rating || 1;
                    const dateSuffix = card.ratedDate ? ` // ${card.ratedDate}` : '';
                    if (card.english) {
                        return `${card.chinese} // ${rating}${dateSuffix}\n${card.english}`;
                    } else {
                        return `${card.chinese} // ${rating}${dateSuffix}`;
                    }
                }).join('\n\n');
            }

            textarea.value = content;

        }

        // ============ TEXT-TO-SPEECH ============
        function speakChinese() {
            if (allCards.length === 0) return;

            const card = allCards[currentIndex];
            const languageSelect = document.getElementById('languageSelect');
            const speechRateSelect = document.getElementById('speechRate');
            const selectedLang = languageSelect.value;
            const selectedRate = parseFloat(speechRateSelect.value);

            // Cancel any ongoing speech
            speechSynthesis.cancel();

            const utterance = new SpeechSynthesisUtterance(card.chinese);
            utterance.lang = selectedLang;
            utterance.rate = selectedRate;
            utterance.pitch = 1;
            utterance.volume = 1;

            // Voice selection - prioritize Google voices (best quality)
            const voices = speechSynthesis.getVoices();
            console.log('Available voices:', voices.length);

            let chineseVoice = null;

            // 1. Try Google voice with exact match
            chineseVoice = voices.find(v =>
                v.lang === selectedLang && v.name.includes('Google')
            );
            console.log('Google exact match:', chineseVoice?.name);

            // 2. Try Enhanced/Premium voices
            if (!chineseVoice) {
                chineseVoice = voices.find(v =>
                    v.lang === selectedLang &&
                    (v.name.includes('Enhanced') || v.name.includes('Premium'))
                );
                console.log('Enhanced/Premium:', chineseVoice?.name);
            }

            // 3. Any exact language match
            if (!chineseVoice) {
                chineseVoice = voices.find(v => v.lang === selectedLang);
                console.log('Exact lang match:', chineseVoice?.name);
            }

            // 4. Starts with language code
            if (!chineseVoice) {
                chineseVoice = voices.find(v => v.lang.startsWith(selectedLang));
                console.log('Starts with match:', chineseVoice?.name);
            }

            // 5. Any Chinese voice as fallback
            if (!chineseVoice) {
                chineseVoice = voices.find(v => v.lang.startsWith('zh'));
                console.log('Any Chinese fallback:', chineseVoice?.name);
            }

            if (chineseVoice) {
                utterance.voice = chineseVoice;
                console.log('Using voice:', chineseVoice.name, chineseVoice.lang);
            }

            speechSynthesis.speak(utterance);
        }

        async function pasteFromClipboard() {
            const textarea = document.getElementById('inputTextarea');

            try {
                // Clear textarea first
                textarea.value = '';

                // Paste from clipboard
                const text = await navigator.clipboard.readText();
                textarea.value = text;
    

                // After 1 second, trigger load
                setTimeout(() => {
                    loadFlashcards();
                }, 1000);
            } catch (err) {
                console.error('Failed to read clipboard:', err);
                alert('Could not access clipboard. Please paste manually.');
            }
        }

        // ============ CANVAS DRAWING ============
        let canvas, ctx, gridCanvas, gridCtx;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let strokeSizeValue = 2;
        let showGrid = true;
        let history = [];
        let canvasInitialized = false;
        let isDarkMode = false;
        let isExpanded = false;

        function initCanvas() {
            if (canvasInitialized) return;

            canvas = document.getElementById('drawCanvas');
            ctx = canvas.getContext('2d');
            gridCanvas = document.getElementById('gridCanvas');
            gridCtx = gridCanvas.getContext('2d');

            // Size canvas
            const size = Math.min(window.innerWidth - 40, 400);
            canvas.width = gridCanvas.width = size;
            canvas.height = gridCanvas.height = size;

            // Drawing settings
            ctx.strokeStyle = '#000';
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = strokeSizeValue;

            // Event listeners
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            canvas.addEventListener('touchstart', startDrawing);
            canvas.addEventListener('touchmove', draw);
            canvas.addEventListener('touchend', stopDrawing);

            drawGrid();
            canvasInitialized = true;
        }

        function drawGrid() {
            if (!gridCtx) return;

            gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
            if (!showGrid) return;

            const size = gridCanvas.width;
            gridCtx.strokeStyle = isDarkMode ? '#6b7280' : '#ccc';
            gridCtx.lineWidth = 1;

            // Outer box
            gridCtx.strokeRect(0, 0, size, size);

            // Cross lines
            gridCtx.beginPath();
            gridCtx.moveTo(size/2, 0);
            gridCtx.lineTo(size/2, size);
            gridCtx.moveTo(0, size/2);
            gridCtx.lineTo(size, size/2);
            gridCtx.stroke();

            // Diagonal guides
            gridCtx.setLineDash([5, 5]);
            gridCtx.beginPath();
            gridCtx.moveTo(0, 0);
            gridCtx.lineTo(size, size);
            gridCtx.moveTo(size, 0);
            gridCtx.lineTo(0, size);
            gridCtx.stroke();
            gridCtx.setLineDash([]);
        }

        function saveState() {
            history.push(canvas.toDataURL());
            if (history.length > 20) history.shift();
        }

        function undo() {
            if (history.length > 0) {
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                history.pop();
                if (history.length > 0) {
                    img.src = history[history.length - 1];
                } else {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            }
        }

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function startDrawing(e) {
            e.preventDefault();
            saveState();
            isDrawing = true;
            const pos = getPos(e);
            lastX = pos.x;
            lastY = pos.y;
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();

            const pos = getPos(e);

            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();

            lastX = pos.x;
            lastY = pos.y;
        }

        function stopDrawing() {
            isDrawing = false;
        }

        function clearCanvas() {
            if (!canvas) return;
            saveState();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function toggleGrid() {
            showGrid = !showGrid;
            drawGrid();
        }

        function toggleDarkCanvas() {
            isDarkMode = !isDarkMode;
            const darkBtn = document.querySelector('.dark-btn');

            if (isDarkMode) {
                // Dark mode: dark gray background, white stroke
                canvas.style.background = '#374151';
                ctx.strokeStyle = '#fff';
                darkBtn.classList.add('active');
                darkBtn.textContent = 'Light';
            } else {
                // Light mode: white background, black stroke
                canvas.style.background = '#fff';
                ctx.strokeStyle = '#000';
                darkBtn.classList.remove('active');
                darkBtn.textContent = 'Dark';
            }
            drawGrid();
        }

        function updateStroke() {
            strokeSizeValue = document.getElementById('strokeSize').value;
            if (ctx) ctx.lineWidth = strokeSizeValue;
        }

        function toggleExpandCanvas() {
            isExpanded = !isExpanded;
            const expandBtn = document.getElementById('expandBtn');
            const flashcard = document.getElementById('flashcard');
            const originalSize = Math.min(window.innerWidth - 40, 400);
            const newWidth = isExpanded
                ? flashcard.offsetWidth - 20
                : originalSize;

            canvas.width = gridCanvas.width = newWidth;
            canvas.height = gridCanvas.height = originalSize;

            // Reapply drawing settings after resize
            ctx.strokeStyle = isDarkMode ? '#fff' : '#000';
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = strokeSizeValue;

            expandBtn.classList.toggle('active', isExpanded);
            expandBtn.textContent = isExpanded ? 'Shrink' : 'Expand';

            drawGrid();
            history = [];
        }

        // ============ EVENT LISTENERS ============
        document.addEventListener('DOMContentLoaded', () => {
            // Handle Dropbox OAuth redirect
            handleDropboxOAuthRedirect();

            // Dropbox button listeners
            document.getElementById('dropboxBtn').addEventListener('click', toggleDropboxSidebar);
            document.getElementById('dbxCloseBtn').addEventListener('click', closeDropboxSidebar);
            document.getElementById('dbxSignInBtn').addEventListener('click', handleDropboxSignIn);
            document.getElementById('dbxSignOutBtn').addEventListener('click', handleDropboxSignOut);
            document.getElementById('dbxSearchBtn').addEventListener('click', handleDbxSearch);
            document.getElementById('dbxSearchInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleDbxSearch();
            });
            document.getElementById('dbxResults').addEventListener('click', handleDbxResultClick);
            document.getElementById('dbxBreadcrumb').addEventListener('click', (e) => {
                const link = e.target.closest('.dbx-breadcrumb-link');
                if (link) loadDropboxFolder(link.dataset.path);
            });
            document.getElementById('dbxSaveBtn').addEventListener('click', saveToDropbox);

            // Load voices
            speechSynthesis.addEventListener('voiceschanged', () => {
                speechSynthesis.getVoices();
            });

            // Initialize canvas immediately (always visible)
            initCanvas();

            // Initialize sidebar
            loadFiles();

            // Show access code input only on production
            if (!isLocalhost) {
                document.getElementById('accessCodeSection').style.display = 'block';
            }

            // Load sample data initially
            loadFlashcards();

            // Navigation buttons
            document.getElementById('prevBtn').addEventListener('click', goBackAndSpeak);
            document.getElementById('nextBtn').addEventListener('click', nextAndSpeak);
            document.getElementById('resetBtn').addEventListener('click', () => {
                currentIndex = 0;
                updateDisplay();
            });

            // Flashcard click: reveal then next
            document.getElementById('flashcard').addEventListener('click', handleFlashcardClick);


            // Control buttons
            document.getElementById('speakRevealBtn').addEventListener('click', goBackAndSpeak);
            document.getElementById('nextSpeakBtn').addEventListener('click', nextAndSpeak);
            document.getElementById('loadBtn').addEventListener('click', loadFlashcards);
            document.getElementById('pasteBtn').addEventListener('click', pasteFromClipboard);
            document.getElementById('saveFileBtn').addEventListener('click', saveCurrentFile);
            document.getElementById('updateTextareaBtn').addEventListener('click', updateTextarea);
            document.getElementById('resetRatingsBtn').addEventListener('click', resetAllRatings);

            // Filter toggle
            document.getElementById('filterToggle').addEventListener('change', toggleFilter);

            // Rating buttons
            document.getElementById('rate1Btn').addEventListener('click', () => { rateCard(1); navigate(1); });
            document.getElementById('rate2Btn').addEventListener('click', () => { rateCard(2); navigate(1); });
            document.getElementById('rate3Btn').addEventListener('click', () => { rateCard(3); navigate(1); });

            // Big rating buttons
            document.getElementById('bigRate1Btn').addEventListener('click', () => { rateCard(1); navigate(1); });
            document.getElementById('bigRate2Btn').addEventListener('click', () => { rateCard(2); navigate(1); });
            document.getElementById('bigRate3Btn').addEventListener('click', () => { rateCard(3); navigate(1); });

            // Auto-reveal toggle
            const autoRevealToggle = document.getElementById('autoRevealToggle');

            // Load saved preference
            const savedAutoReveal = localStorage.getItem('flashcard-autoReveal');
            if (savedAutoReveal === 'true') {
                autoReveal = true;
                autoRevealToggle.checked = true;
            }

            autoRevealToggle.addEventListener('change', function() {
                autoReveal = this.checked;
                localStorage.setItem('flashcard-autoReveal', autoReveal.toString());
                // Re-display current card with new setting
                updateDisplay();
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                // Don't handle if typing in textarea or input
                if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

                // Rating shortcuts (1, 2, 3 keys) - prioritize rating over card navigation
                if (e.key === '[' && !e.metaKey && !e.ctrlKey) {
                    e.preventDefault();
                    rateCard(1);
                    navigate(1);
                    return;
                }
                if (e.key === ']' && !e.metaKey && !e.ctrlKey) {
                    e.preventDefault();
                    rateCard(2);
                    navigate(1);
                    return;
                }
                if (e.key === '\\' && !e.metaKey && !e.ctrlKey) {
                    e.preventDefault();
                    rateCard(3);
                    navigate(1);
                    return;
                }

                // Number keys (1-9, 0) for card selection - skip if Cmd/Ctrl held (browser tab switching)
                if ((e.key >= '1' && e.key <= '9' || e.key === '0') && !e.metaKey && !e.ctrlKey) {
                    e.preventDefault();
                    handleDigitInput(e.key);
                    return;
                }

                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        goBackAndSpeak();
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        nextAndSpeak();
                        break;
                    case ' ':
                        e.preventDefault();
                        goBackAndSpeak();
                        break;
                    case 'Enter':
                        e.preventDefault();
                        if (allCards.length > 0) {
                            speechSynthesis.cancel();
                            const msg = new SpeechSynthesisUtterance(`${currentIndex + 1} of ${allCards.length}`);
                            msg.lang = 'en-US';
                            msg.rate = 1;
                            speechSynthesis.speak(msg);
                        }
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        speakChinese();
                        break;
                    case 's':
                    case 'S':
                        e.preventDefault();
                        speakChinese();
                        break;
                }
            });
        });
    </script>
</body>
</html>

